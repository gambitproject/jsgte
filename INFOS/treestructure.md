Dear Cesar and Alfonso,

thanks for your emails. By "single point of truth" I mean
one should store information where it belongs so that one
avoids duplication that then needs to be kept consistent.

I had a rather clean way of storing game tree in a C program
where the most important definition is in the C header file

https://github.com/stengel/ecta2002/blob/master/treedef.h

and has 4 basic "classes" if you like, namely structures

    node  
    iset
    move
    outcome

where the corresponding capital letters are pointers to
these structures. I recommend using that structure and
explain it here:

    struct node
        {
        Bool        terminal;       /* 0: decision node / 1: terminal node  */
        Iset        iset;           /* which information set                */
        Node        father;         /* node closer to root                  */
        Move        reachedby;      /* move of edge from father             */
        Outcome     outcome;        /* which outcome                        */
        /* will be generated by  genseqin()                                 */
        Move        defseq[PLAYERS];/* seq defd by node for each player     */
        };


struct iset     /* information set      */
    {
    /* given                    */
    int         player;         /* 0: chance player                     */
    int         nmoves;
    Move        move0;
    /* autoname possible                                                */
    char        name[NAMECHARS];        /* name of iset                 */
    /* will be generated                                                */
    Move        seqin;          /* sequence leading to that iset        */
    /* for NF computation                                               */
    int         ncontin;        /* how many strategy-type continuations */
    int         prefact;        /* multiplyer for later parallel isets  */
    };

struct move   /* move, also sequence ending in that move        */
    {
    Iset        atiset;         /* where this move emanates from        */
    Rat         behavprob;      /* behavior probability                 */
    Rat         realprob;       /* realization probability              */
    int         redsfcol;       /* column of reduced sequence form      */
    /* for NF computation                                               */
    int         ncompat;        /* number of compatible partial strats  */
    int         offset;         /* number of partial strats for moves   */
				/* to the right of this at same iset    */
    };

struct outcome
    {
    Payvec      pay;
    Node        whichnode;
    };

/* ------------- global variables ------------------------------------- */
/* game tree                                    */
extern  Node    nodes;          /* nodes of game tree   */
extern  Node    root;           /* &nodes[ROOT]         */
extern  Iset    isets;          /* information sets     */
extern  Move    moves;          /* moves & sequences    */
extern  Outcome outcomes;       /* outcomes             */
/* sizes of these arrays                                                */
/* first ILLEGAL pointer at the end of array nodes      */
extern  Node lastnode;
/* isets for player  pl:  firstiset[pl] ... firstiset[pl+1]-1       */
extern  Iset firstiset[PLAYERS+1];
/* moves for player  pl:  firstmove[pl] ... firstmove[pl+1]-1       */
extern  Move firstmove[PLAYERS+1];
/* first ILLEGAL pointer at end of array outcomes */
extern  Outcome lastoutcome;

/* number of sequences for each player          */
extern  int nseqs[PLAYERS];     
/* number of information sets for each player   */
extern  int nisets[PLAYERS];

/* alloctree:
 * after freeing space used for old tree,
 * allocate storage space for a game tree with 
 * nn  nodes    (determines  lastnode)
 * ni  isets    (determines  firstiset[PLAYERS] )
 * nm  moves    (determines  firstmove[PLAYERS] )
 * no  outcomes (determines  lastoutcome)
 */
void alloctree(int nn, int ni, int nm, int no);

/* ----------- generating derived tree data -------------------- */
/* checks perfect recall, returns 1 if there is a problem 
 * sets  sequence triples leading to nodes & seqin for isets
 * sets  nseqs[], nisets[]
 */
Bool genseqin(void);

/* next integer representing payoff, using MAXRANDPAY   */
int nextrandpay (void); 

/* normalize maximum payoff to players to -1
 * bprint:  announce current max payoffs to stdout
 */
void maxpayminusone(Bool bprint);

/* names  isets  using an1[pl]..an2[pl]
 * assume nisets[] set  by  genseqin()
 */
void autoname(void);

/* ----------- output routines --------------------------------- */
/*
 * convert  c  of player  pl  to string  s
 * c == NULL:  s = "*".  c == empty sequence: s="()"
 * o/w  iset's name + move no
 * returns length of string.  s must be long enough
 */
int movetoa (Move c, int pl, char *s);

/* convert sequence  seq  of player  pl  to string  s  
 * c == NULL:  s = "*".  c == empty sequence: s="." 
 * returns length of string.  s must be long enough
 */
int seqtoa (Move seq, int pl, char *s);

/* prints the raw tree data                     */
void rawtreeprint(void);

