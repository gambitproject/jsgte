Dear Cesar and Alfonso,

thanks for your emails. By "single point of truth" I mean
one should store information where it belongs so that one
avoids duplication that then needs to be kept consistent.

My point was that MOVES should be associated with
information sets, but I think information sets should be
objects of their own right.

# Game tree - logical structure

## Four basic "classes" `node`  `iset` `move` `outcome`

I had a rather clean way of storing game tree in a C program
where the most important definition is in the C header file

https://github.com/stengel/ecta2002/blob/master/treedef.h

and has 4 basic "classes" if you like, namely structures

    node  
    iset
    move
    outcome

where the corresponding capital letters

    Node
    Iset
    Move
    Outcome 

are pointers to these structures, which in C can be both
pointers to individual structures as well as ARRAYS of them.
You will see later in the file 

    /* ------------- global variables ------------------------------------- */
    /* game tree                                    */
    extern  Node    nodes;          /* nodes of game tree   */
    extern  Node    root;           /* &nodes[ROOT]         */
    extern  Iset    isets;          /* information sets     */
    extern  Move    moves;          /* moves & sequences    */
    extern  Outcome outcomes;       /* outcomes             */

but in fact there is no reason to put all these things into
arrays, they could equally be in linked lists or even in the
tree itself which you have to traverse somehow.

The tree is a set of nodes which are of the form

    struct node
        {
        Bool        terminal;       /* 0: decision node / 1: terminal node  */
        Iset        iset;           /* which information set                */
        Node        father;         /* node closer to root                  */
        Move        reachedby;      /* move of edge from father             */
        Outcome     outcome;        /* which outcome                        */

        /* will be generated by  genseqin()                                 */
        Move        defseq[PLAYERS];/* seq defd by node for each player     */
        };

so you see for each node you should know to which
information set it belongs, what its father is, by which
move it is reach from its father, and what outcome it is
(normally only relevant if the node is terminal).

There is also a tuple `defseq` of moves, one for each player
(including chance) where `defseq[pl]` means the LAST
move on the path to the current root by player `pl`.
This is derived information use to find out if the game has
perfect recall, and to compute expected payoffs when
converting it to the strategic form.

    struct iset     /* information set      */
        {
        /* given                    */
        int         player;         /* 0: chance player                     */
        int         nmoves;
        Move        move0;
        /* autoname possible                                                */
        char        name[NAMECHARS];        /* name of iset                 */
        /* will be generated                                                */
        Move        seqin;          /* sequence leading to that iset        */
        /* for NF computation                                               */
        int         ncontin;        /* how many strategy-type continuations */
        int         prefact;        /* multiplyer for later parallel isets  */
        };

`iset` represents an information set, including `player`
(so the player to move at a node `n` would be
`n->iset->player`, I suppose `n.iset.player` in JS),
`nmoves` for the number of moves at the information set,
`move0` would be the first of these moves, where from this
move you would successively reach the second, third, move,
and so on (I had them successively stored in an array, but
this is not important).
Here `name[NAMECHARS]` is just a string which I used as the
name for the information set for output purposes.

`seqin` is the last move of the player who owns the
information set on the path from the root to any node in the
set. Important for the "sequence form" algorithm. 

`ncontin` and and `prefact` are important for generating
reduced strategies.

    struct move   /* move, also sequence ending in that move        */
        {
        Iset        atiset;         /* where this move emanates from        */
        Rat         behavprob;      /* behavior probability                 */
        Rat         realprob;       /* realization probability              */
        int         redsfcol;       /* column of reduced sequence form      */
        /* for NF computation                                               */
        int         ncompat;        /* number of compatible partial strats  */
        int         offset;         /* number of partial strats for moves   */
                    /* to the right of this at same iset    */
        };

This is information stored with each move. `atiset`
identifies to which information set it belongs.

    struct outcome
        {
        Payvec      pay;
        Node        whichnode;
        };

For an outcome, the vector of payoffs, and to which node the
outcome belongs.

## Traversing a game tree

In order to build certain structures, for example to
generate all strategies in the game tree, you have to
traverse the entire game tree, typically its nodes.

I had an *array* of all tree nodes where the father of a
node had to come earlier in the array, so the root must be
the first node in the array.

In my application, I knew the structure of the game tree in
advance, but we generate it interactively.
So an array is not a good data structure.

I presume each node has a list of its children, which allows
for an easy recursive _depth-first_ traversal.

However, for the automatic naming of moves, _breadth-first_
is better, which requires a harder-to-implement queue.

The question is if one should LINK the nodes (with some kind
of `next` pointer) so that one can follow these links for a
breadth-first traversal. It then has to be maintained
consistently, which may be a source of errors.  
Alternatively, it may be worth COMPUTING this structure from
scratch when needed, for example for the autoname feature or
for creating the XML file.
