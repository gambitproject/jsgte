The main **logical** objects for a game tree
(to describe their function in the game) are
- players
- nodes
- information sets (info set or iset for short)
- moves
- outcomes

The logical structure can be organized so that data is
stored in a unique place:
for example, a node belongs to an info set (which can be a
singleton containing only that node, the default), and the
info set belongs to player. So there is no need to store the
player with the node.

This structure (in C) is described in the C program that I
wrote at
https://github.com/stengel/ecta2002/blob/master/treedef.h
which specifies the types (essentially classes, each defined
as a `struct`) node, iset, move, outcome. (The respective capitalized names
Node, Iset, Move, Outcome are pointers to these structures.)

Example (I notice the overloading of "iset" and "outcome" for both field names and types which should not be the case):
    
    struct node
        {
        Bool        terminal;       /* 0: decision node / 1: terminal node  */
        Iset        iset;           /* which information set                */
        Node        father;         /* node closer to root                  */
        Move        reachedby;      /* move of edge from father             */
        Outcome     outcome;        /* which outcome                        */
        /* will be generated by  genseqin()                                 */
        Move        defseq[PLAYERS];/* seq defd by node for each player     */
        }; 

Here, the tree structure is completely described by recording for each node its **father**.

However, for the graphical display it is also useful to record the children of each
node in the order in which they appear, e.g. with a `firstchild` which starts a list of its siblings.

